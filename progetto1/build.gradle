//le librerie vanno in formato gradle

/* librerie da mettere nell'ear puntate dai progetti --> earLib.txt
 	librerie da deployare con i progetti --> 
 		se comuni a tutti i progetti di quel tipo [tipo_progetto].txt (war.txt) 
 		se particolari [nome_progetto]_[tipo_progetto].txt (contWeb_war.txt)
 	librerie del servlet container
 		comuni per tutti --> jboss.txt
 		solo per i war --> jboss_war.txt
 		solo per ejb --> jboss_ejb.txt
 		
 		
 	jar da aggiungere
 		nell'ear --> extEarLib
 		nel war in compilazione --> extWarLib
 		nel war provided --> extWarLibP
 		nel ejb in compilazione vanno nell'ear
 		nel ejb provided --> extEjbLibP
 		
 		
*/
import groovy.io.FileType

//direcotory locale del jboss
def jbossDirectory="/opt/server/contabilita/jboss-eap-6.4"

allprojects {
	//task per comandare il jboss

task restartJboss(type:Exec) {
  workingDir "${jbossDirectory}/bin"

  
  commandLine './jboss-cli.sh --connect --command=:reload'


  ext.output = {
    return standardOutput.toString()
  }
}

task shutdownJboss(type:Exec) {
  workingDir "${jbossDirectory}/bin"  
  executable "sh" 
  args "-c", './jboss-cli.sh --connect --command=:shutdown'


  ext.output = {
    return standardOutput.toString()
  }
}




task startJboss(type:Exec) {
  workingDir "${jbossDirectory}/bin"
  executable "sh"
  args "-c", "./standalone.sh -b 0.0.0.0 "
  ext.output = {
    return standardOutput.toString()
  }
}
	
   
}

subprojects{
	apply plugin:"java"
	repositories {
		mavenCentral()
		maven{
    		//zkoss maven repo    	
  			url 'https://repository.jboss.org/nexus/content/groups/public/'
    	}
        maven{
    		//jboss maven repo
    		url  "http://mavensync.zkoss.org/maven2"
  		}
  	}
}


//setup dell'ear


project(':ContEar'){
	//modalità backend viene eseguito il deploy anche dell'ejb.
	//modalità frontend viene eseguito il deploy delle sole interfacce Remote
	def earMode = 'backend'
		
	//progetti ejb contenuti nell'ear con gli ejb di interfacce remote usate per chiamarlo
	def ejbProjects = [':ContEjb':[':ContEjbRemote']]
	
	//progetti war con gli ejb da usare nel progetto
	//verranno caricate nel war le sole interfacce remote
	def warProjects = [':ContWeb':[':ContEjbRemote']]
			
	ejbProjects.each{
		project(it.key).ext.set('remoteCallEjb',it.value)
	}
	
	

	task undeployEarToJboss <<{
	 delete ("${jbossDirectory}/standalone/deployments/${project.name}.ear")
     delete ("${jbossDirectory}/standalone/deployments/${project.name}.ear.undeployed")
   	
   }

	task deployEarToJboss <<{
	 copy {
      from ("${project.buildDir}/libs"){
      	 include '**/*.ear'
      }
      into "${jbossDirectory}/standalone/deployments/"
     	
   }
   }
   task assbembleAndDeployJboss(dependsOn: [clean,assemble,deployEarToJboss])<<{
	println("COMPLETED");	
	}
	
	assemble.mustRunAfter clean
	deployEarToJboss.mustRunAfter assemble

	
   


	apply plugin:"ear"	
	
	//caricamento librerie da mettere nell'ear
	def earLib = new File("${project.rootDir}/earLib.txt").exists()?new File("${project.rootDir}/earLib.txt") as String[]:[]
	
	dependencies {
		//qui carico tutte le librerie definite nel file lib.properties 
		earLib.each{	
			earlib it;
		}
			    
	    //carico i jar che vanno inseriti nell'ear
		earlib fileTree(dir: "${project.rootDir}/extEarLib", includes: ['**/*.jar'])
		
		
		
		
		
		//inserire qui i progetti contenuti	nell'ear
		
		//progetti war
		
		warProjects.each{war->
			project(war.key).ext.set('ejbToCall',warProjects.get(war.key));
			deploy project(path: war.key, configuration: 'archives')
		}
	    
	    
	    //progetti ejb. Ogni progetto ejb si porta dietro l'ejb delle interfacce remote.
	    
	    ejbProjects.each{ejb->
	    	//l'ejb si distribuisce solo in backend
	    	if (!(earMode=="frontend")){
	    		deploy project(ejb.key)
	    	}
	    	
	    	//controllo se ci sono eventuali chiamate remote da implementare
	    	//per quell'ejb e carico l'ejb remoto nell'ear
	    	ejb.value.each{
	    		deploy project(it)
	    	}
	    }
	  
	}	
		
	ear {
	    appDirName 'src/main/app'  // use application metadata found in this folder
	    // put dependent libraries into APP-INF/lib inside the generated EAR
	    libDirName 'APP-INF/lib' 
	   
	   
	    deploymentDescriptor {  
	
	        applicationName = "Test"
	        initializeInOrder = true
	        displayName = 	    
	        description = "Ear di test"	    
	          	
	      	//context per i moduli war
	      	webModule("ContWeb.war", "Test")
	        
	    }
	}
			
}

//setup del war. Copiare il template per ogni nuovo war
//e inserire i parametri di deploy del war nell'EAR

project(':ContWeb'){
	apply plugin:"war"
	project.webAppDirName="WebContent"
	version = ''
	//librerie presenti nell'ear
	def earLib = new File("${project.rootDir}/earLib.txt").exists()?new File("${project.rootDir}/earLib.txt") as String[]:[]
	//librerie comuni ai war
	def warLib = new File("${project.rootDir}/war.txt").exists()?new File("${project.rootDir}/war.txt") as String[]:[]
	//librerie war specifiche del progetto
	def warLibP = new File("${project.rootDir}/${project.name}_war.txt").exists()?new File("${project.rootDir}/${project.name}_war.txt") as String[]:[]
	//librerie comuni del jboss
	def jbossCommonLib = new File("${project.rootDir}/jboss.txt").exists()?new File("${project.rootDir}/jboss.txt") as String[]:[]
	//librerie del jboss per i war
	def jbossWarLib = new File("${project.rootDir}/jboss_war.txt").exists()?new File("${project.rootDir}/jboss_war.txt") as String[]:[]
	// librerie tipiche del progetto
	
	
	
		
	dependencies {
		//carico tutte le librerie dell'ear
		//queste non vanno inserite nel war ma sono già presenti nell'ear
		earLib.each{	
			providedCompile it;
		}
					
		//librerie da inserire in WEB-INF/lib 
		warLib.each{	
			compile it;
		}
		warLibP.each{	
			compile it;
		}
		//carico le librerie comuni del jboss
		jbossCommonLib.each{	
			providedCompile it;
		}
		//carico le librerie comuni del jboss per i war
		jbossWarLib.each{	
			providedCompile it;
		}
		
		//carico i jar che vanno distribuiti col war	
		compile fileTree(dir: "${project.rootDir}/extWarLib", includes: ['**/*.jar']) 
		
		//carico i jar che non vanno distribuiti col war
		providedCompile fileTree(dir: "${project.rootDir}/extWarLibP", includes: ['**/*.jar']) 
				
		//inserire qui i progetti ejb che il war deve usare ma che sono presenti nell'ear
	
		//di norma le interfacce remote vanno nell'ear che contiene il war
				
		project.ext.ejbToCall.each{
		remoteInterface->
			providedCompile(project (remoteInterface))
		}
		
		
		
	
	}
	
			
	war {
		baseName="${project.name}"
   	// from 'src/main/webapp' // adds a file-set to the root of the archive
	    webInf { from 'src/main/pagesUnderWebinf' } // adds a file-set to the WEB-INF dir.
	    classpath fileTree('${project.rootProject}/additionalLibs') // adds a file-set to the WEB-INF/lib dir.
	    webXml = file('src/web.xml') // copies a file to WEB-INF/web.xml
   
	}	
		
	
}


//ejb. Inserire i deploy anche nell'ear

project(':ContEjb'){

	apply plugin:"war"
	//librerie presenti nell'ear
	def earLib = new File("${project.rootDir}/earLib.txt").exists()?new File("${project.rootDir}/earLib.txt") as String[]:[]
	//librerie comuni del jboss
	def jbossCommonLib = new File("${project.rootDir}/jboss.txt").exists()?new File("${project.rootDir}/jboss.txt") as String[]:[]
	//librerie del jboss per i war
	def jbossEjbLib = new File("${project.rootDir}/jboss_ejb.txt").exists()?new File("${project.rootDir}/jboss_ejb.txt") as String[]:[]
	
	//librerie comuni agli ejb
	def ejbLib = new File("${project.rootDir}/ejb.txt").exists()?new File("${project.rootDir}/war.txt") as String[]:[]
	//librerie ejb specifiche del progetto
	def ejbLibP = new File("${project.rootDir}/${project.name}_ejb.txt").exists()?new File("${project.rootDir}/${project.name}_ejb.txt") as String[]:[]
		
	dependencies {
		//librerie dell'ear
		earLib.each{	
			providedCompile it;
		}
	
		//carico le librerie comuni del jboss
		jbossCommonLib.each{	
			providedCompile it;
		}
		//carico le librerie comuni del jboss per gli ejb
		jbossEjbLib.each{
			providedCompile it;
		}
	
		
		//carico i jar che non vanno distribuiti col ejb
		providedCompile fileTree(dir: "${project.rootDir}/extEjbLibP", includes: ['**/*.jar']) 
		 
		 //interfacce remote che vanno nell'ear automaticamente
		project.remoteCallEjb.each{			
			providedCompile project(path:it) 
		}
		

	}
	
	
	
}



project(':ContEjbRemote'){
	apply plugin:"war"
	//librerie presenti nell'ear
	def earLib = new File("${project.rootDir}/earLib.txt").exists()?new File("${project.rootDir}/earLib.txt") as String[]:[]
	//librerie comuni del jboss
	def jbossCommonLib = new File("${project.rootDir}/jboss.txt").exists()?new File("${project.rootDir}/jboss.txt") as String[]:[]
	//librerie del jboss per i war
	def jbossEjbLib = new File("${project.rootDir}/jboss_ejb.txt").exists()?new File("${project.rootDir}/jboss_ejb.txt") as String[]:[]
	
	//librerie comuni agli ejb
	def ejbLib = new File("${project.rootDir}/ejb.txt").exists()?new File("${project.rootDir}/war.txt") as String[]:[]
	//librerie ejb specifiche del progetto
	def ejbLibP = new File("${project.rootDir}/${project.name}_ejb.txt").exists()?new File("${project.rootDir}/${project.name}_ejb.txt") as String[]:[]
	
	
	dependencies {
		
		
		//librerie dell'ear
		earLib.each{	
			providedCompile it;
		}
	
		//carico le librerie comuni del jboss
		jbossCommonLib.each{	
			providedCompile it;
		}
		//carico le librerie comuni del jboss per gli ejb
		jbossEjbLib.each{
			providedCompile it;
		}
		
		//carico i jar che vanno distribuiti col ejb	
		compile fileTree(dir: "${project.rootDir}/extEjbLib", includes: ['**/*.jar']) 
		
		//carico i jar che non vanno distribuiti col ejb
		providedCompile fileTree(dir: "${project.rootDir}/extEjbLibP", includes: ['**/*.jar']) 
		
		
		
		//inserire qui le dipendenze da altri ejb
		//providedCompile se presenti nell'ear
		//compile se vanno distribuiti col pacchetto
	
	}
	
}

